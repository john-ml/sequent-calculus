sequent calculus language thing

Types
  τ ∷= 0 | 1
     | σ + τ
     | σ × τ
     | σ → τ
     | ¬ τ

Typing contexts
  Γ, Δ ∷= · | Γ, x : τ

Terms
     
  e ∷=

     Variables
     | [k]x
     | let x = κ k. e₁ in e₂

     Unit and zero
     | absurd x
     | [k]★

     Products
     | pair k (κ h. e₁) (κ j. e₂)
     | let (y, z) = x in e

     Sums
     | let [h, j] = k in e
     | case x (λ y. e₁) (λ z. e₂)

     Functions
     | [k](λ x. κ j. e)
     | let y = x (κ k. e₁) in e₂

     Negation
     | let x -> k in e
     | let x <- k in e

Typing judgment Γ ⊢ e ⊣ Δ

  Axiom (context lookup)

    ——————————————————————————
    Γ, x : τ ⊢ [k]x ⊣ k : τ, Δ
 
       Γ ⊢ [k]x ⊣ Δ
    ——————————————————— x ≠ y
    Γ, y : τ ⊢ [k]x ⊣ Δ
 
       Γ ⊢ [k]x ⊣ Δ
    ——————————————————— j ≠ k
    Γ ⊢ [k]x ⊣ j : τ, Δ

  Cut

    Γ ⊢ e₁ ⊣ k : τ, Δ    Γ, x : τ ⊢ e₂ ⊣ Δ
    ——————————————————————————————————————
        Γ ⊢ let x = κ k. e₁ in e₂ ⊣ Δ

  Unit and zero

    ——————————————————    ——————————————
    x : 0 ⊢ absurd x ⊣    ⊢ [k]★ ⊣ k : 1

  Products

       Γ ⊢ e₁ ⊣ h : σ, Δ    Γ ⊢ e₂ ⊣ j : τ, Δ
    —————————————————————————————————————————————
    Γ ⊢ pair k (κ h. e₁) (κ j. e₂) ⊣ k : σ × τ, Δ

           Γ, y : σ, z : τ ⊢ e ⊣ Δ
    ——————————————————————————————————————
    Γ, x : σ × τ ⊢ let (y, z) = x in e ⊣ Δ

  Sums

           Γ ⊢ e ⊣ h : σ, j : τ, Δ
    ——————————————————————————————————————
    Γ ⊢ let [h, j] = k in e ⊣ k : σ + τ, Δ

     Γ, y : σ ⊢ e₁ ⊣ Δ    Γ, z : τ ⊢ e₂ ⊣ Δ
    —————————————————————————————————————————
    Γ, x : σ + τ ⊢ case x (λ y. e₁) (λ z. e₂)

  Functions

          Γ, x : σ ⊢ e ⊣ j : τ, Δ
    ———————————————————————————————————
    Γ ⊢ [k](λ x. κ j. e) ⊣ k : σ → τ, Δ

       Γ ⊢ e₁ ⊣ k : σ, Δ    Γ, y : τ ⊢ e₂ ⊣ Δ
    ————————————————————————————————————————————
    Γ, x : σ → τ ⊢ let y = x (κ k. e₁) in e₂ ⊣ Δ

  Negation

            Γ ⊢ e ⊣ k : τ, Δ
    ————————————————————————————————
    Γ, x : ¬ τ ⊢ let x -> k in e ⊣ Δ

            Γ, x : τ ⊢ e ⊣ Δ
    ————————————————————————————————
    Γ ⊢ let x <- k in e ⊣ k : ¬ τ, Δ

Conversion to LC

  [[ _ ]] : term → lc_term such that

    .., x : σ ⊢ e ⊣ k : τ, .. →
    ∀ R. .., x : [[σ]]R, .., k : [[τ]]R → R ⊢ [[e]] : R where

          [[ 0 ]] R = 0
          [[ 1 ]] R = 1
      [[ σ + τ ]] R = [[ σ ]] R + [[ τ ]] R
      [[ σ × τ ]] R = [[ σ ]] R × [[ τ ]] R
      [[ σ → τ ]] R = [[ σ ]] R → ([[ τ ]] R → R) → R
        [[ ¬ τ ]] R = [[ τ ]] R → R

                        [[ [k]x ]] = k x
       [[ let x = κ k. e₁ in e₂ ]] = (λ k. [[e₁]]) (λ x. [[e₂]])
                        [[ [k]★ ]] = k ★
  [[ pair k (κ h. e₁) (κ j. e₂) ]] = (λ h. [[e₁]]) (λ v. (λ j. [[e₂]]) (λ w. k (v, w)))
         [[ let (y, z) = x in e ]] = let (y, z) = x in [[e]]
         [[ let [h, j] = k in e ]] = (λ h j. [[e]]) (λ v. k (ι₁ v)) (λ w. k (ι₂ w))
  [[ case x (λ y. e₁) (λ z. e₂) ]] = case x of ι₁ y -> [[e₁]] | ι₂ z -> [[e₂]] end
            [[ [k](λ x. κ j. e) ]] = k (λ x j. [[e]])
   [[ let y = x (κ k. e₁) in e₂ ]] = (λ k. e₁) (λ v. (λ y. e₂) (x v))
             [[ let x -> k in e ]] = (λ k. [[e]]) x
             [[ let x <- k in e ]] = k (λ x. [[e]])

Negation
  Analogues for
    Γ ⊢ ¬ τ, Δ    Γ, ¬ τ ⊢ Δ
    ——————————    ——————————
     Γ, τ ⊢ Δ      Γ ⊢ τ, Δ
  as derived rules
                                  ————————————————————
                                  x : τ ⊢ [k]x ⊣ k : τ
                          —————————————————————————————————————
    Γ ⊢ _ ⊣ j : ¬ τ, Δ    x : τ, y : ¬ τ ⊢ let y -> k in [k]x ⊣
    ———————————————————————————————————————————————————————————
     Γ, x : τ ⊢ let y : ¬ τ = κ j. _ in let y -> k in [k]x ⊣ Δ
  and
           ————————————————————
           j : τ ⊢ [k]y ⊣ k : τ
    —————————————————————————————————————
    ⊢ let y <- j in [k]y ⊣ j : ¬ τ, k : τ    Γ, x : ¬ τ ⊢ _ ⊣ Δ
    ———————————————————————————————————————————————————————————
    Γ ⊢ let x : ¬ τ = (κ j. let y <- j in [k]y) in _ ⊣ k : τ, Δ
  What control operators do these correspond to?
    [[ let y : ¬ τ = κ j. _ in let y -> k in [k]x ]]
      = (λ j. [[_]]) (λ y. [[ let y -> k in [k]x ]]
      = (λ j. [[_]]) (λ y. (λ k. k x) y)
      = (λ j. [[_]]) (λ y. y x)
      The value x : τ is replaced by a suspension(?) j := (λ k. k x)
    [[ let x : ¬ τ = (κ j. let y <- j in [k]y) in _ ]]
      = (λ j. [[ let y <- j in [k]y ]]) (λ x. [[_]])
      = (λ j. j (λ y. k y)) (λ x. [[_]])
      = (λ j. j k) (λ x. [[_]])
      = let x = k in [[_]]
      The value x : ¬ τ is the current continuation k : τ
  let x -> k in e:
    x : ¬ τ is a captured continuation
    k : τ is a way to invoke the captured continuation in e
  let x <- k in e:
    k : ¬ τ is a suspended computation of τ
    x : τ is the result of resuming k

Cocurrying?
  Currying: p → q → r ≡ p × q → r
  Want infixl (←) s.t. p ← q ← r ≡ p ← q + r
  p ← q := ¬ (p → q) ≡ p × ¬ q works:
    p ← q ← r
      ≡ ¬ (¬ (p → q) → r)
      ≡ p × ¬ q × ¬ r
      ≡ p × ¬ (q + r)
      ≡ p ← q + r
  So p → .. → q → 1 ← r ← .. ← s ≡ p × .. × q → r + .. + s
