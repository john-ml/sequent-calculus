sequent calculus language thing

Types
  τ ∷= 0 | 1
     | σ + τ
     | σ × τ
     | σ → τ
     | ¬ τ

Typing contexts
  Γ, Δ ∷= · | Γ, x : τ

Terms
     
  e ∷=

     Variables
     | [k]x

     Unit and zero
     | [k]★
     | absurd x

     Products
     | pair k (μ h. e₁) (μ j. e₂)
     | let (y, z) = x in e

     Sums
     | let [h, j] = k in e
     | case x (λ y. e₁) (λ z. e₂)

     Functions
     | [k](λ x. μ j. e)
     | [k](x (μ j. e))

     Negation
     | let x -> k in e
     | let x <- k in e

Typing judgment Γ ⊢ e ⊣ Δ

  Axiom (context lookup)

    ——————————————————————————
    Γ, x : τ ⊢ [k]x ⊣ k : τ, Δ
 
       Γ ⊢ [k]x ⊣ Δ
    ——————————————————— x ≠ y
    Γ, y : τ ⊢ [k]x ⊣ Δ
 
       Γ ⊢ [k]x ⊣ Δ
    ——————————————————— j ≠ k
    Γ ⊢ [k]x ⊣ j : τ, Δ

  Unit and zero

    ——————————————————    ——————————————
    x : 0 ⊢ absurd x ⊣    ⊢ [k]★ ⊣ k : 1

  Products

       Γ ⊢ e₁ ⊣ h : σ, Δ    Γ ⊢ e₂ ⊣ j : τ, Δ
    —————————————————————————————————————————————
    Γ ⊢ pair k (μ h. e₁) (μ j. e₂) ⊣ k : σ × τ, Δ

           Γ, y : σ, z : τ ⊢ e ⊣ Δ
    ——————————————————————————————————————
    Γ, x : σ × τ ⊢ let (y, z) = x in e ⊣ Δ

  Sums

           Γ ⊢ e ⊣ h : σ, j : τ, Δ
    ——————————————————————————————————————
    Γ ⊢ let [h, j] = k in e ⊣ k : σ + τ, Δ

     Γ, y : σ ⊢ e₁ ⊣ Δ    Γ, z : τ ⊢ e₂ ⊣ Δ
    —————————————————————————————————————————
    Γ, x : σ + τ ⊢ case x (λ y. e₁) (λ z. e₂)

  Functions

          Γ, x : σ ⊢ e ⊣ j : τ, Δ
    ———————————————————————————————————
    Γ ⊢ [k](λ x. μ j. e) ⊣ k : σ → τ, Δ

               Γ ⊢ e ⊣ j : σ, Δ
    —————————————————————————————————————————
    Γ, x : σ → τ ⊢ [k](x (μ j. e)) ⊣ k : τ, Δ

  Negation

            Γ, x : τ ⊢ e ⊣ Δ
    ————————————————————————————————
    Γ ⊢ let x <- k in e ⊣ k : ¬ τ, Δ

            Γ ⊢ e ⊣ k : τ, Δ
    ————————————————————————————————
    Γ, x : ¬ τ ⊢ let x -> k in e ⊣ Δ

Example: Pierce's law is setjmp/longjmp


                         ———————————————————————————
                         y : σ ⊢ [j]y ⊣ g : τ, j : σ
                —————————————————————————————————————————————
                ⊢ μ h. [h](λ y. μ g. [j]y) ⊣ h : σ → τ, j : σ
         ———————————————————————————————————————————————————————————
         x : (σ → τ) → σ ⊢ [j](x (μ h. [h](λ y. μ g. [j]y))) ⊣ j : σ
  ——————————————————————————————————————————————————————————————————————————
  ⊢ [k](λ x. μ j. [j](x (μ h. [h](λ y. μ g. [j]y)))) ⊣ k : ((σ → τ) → σ) → σ

  Essentially (λ x : (σ → τ) → σ. x (λ y : σ. raise y) handle y -> y)

Example: double negation
  
  
                        ————————————————————
                        y : τ ⊢ [j]y ⊣ j : τ
               —————————————————————————————————————
               ⊢ let y <- h in [j]y ⊣ h : ¬ τ, j : τ
        ————————————————————————————————————————————————————
        x : ¬ ¬ τ ⊢ let x -> h in let y <- h in [j]y ⊣ j : τ
  —————————————————————————————————————————————————————————————————
  ⊢ [k](λ x. μ j. let x -> h in let y <- h in [j]y) ⊣ k : ¬ ¬ τ → τ

















